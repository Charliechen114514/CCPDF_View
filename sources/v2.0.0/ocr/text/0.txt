几 Comprehentsipe Look at RA开                                                                 Chapier5

mutex_guard 19 (四)          /11 Now we lock
。 WOIK on Shared data，now Protected by mutex ...
E (work_done) breaki       1 Exit the scope
。 Worxk on the shared data Some more ..-.
)} while (false);              /1/ lock is released here
。 Ore non-exCclusive WOrK ..-

】}

However this approach does not always work (we may want to release the resources, but
not other local variables we defined in the same scope)j, and the readability of the code
suffers as the control flow gets more complex. Resist the impulse to accomplish this by
allocating the RAII object dynamically, with operator newl This completely defeats the
whole Point of RAIL since you now must remember to invoke operator delete. We can
enhance our resource-managing objects by adding a cient-triggered release, in addition to
the automatic release by the destructor Wejust have to make sure that the same resource is
not released twice. Consider the following example, using scoped_ptr:

template <Lypename T>

class Scoped ptr {
public:
explicit scoped ptr(Tr* p) : pP_(p) {1)}
~sScoped_ ptr() { delete p_; }

void reset() { delete p_i; P_ = nullptri } 。 // Releases resource early
private:
T* p-;

抹

After calling reset ()，the object managed by the scoped_ptr objectis deleted, and the
Pointer data member of the scoped_ptr objectis reset to null Note that we did not need
to add a condition check to the destructor because calling delete on anull pointer is
allowed by the standard一it does nothing. The resource is released only once, either
explicitty by the reset () call or implicitly at the end of the scope containing the

scoped_ptr object

For the mutex_guardclass, we can't deduce from just the lock whether an early release was
called or not and we need an additional data member to keep track of that:

class mutex_guard {
public:
explicit mutex_guard(Std::mUtex& 印) :

有_(四) ，muSt_unlocxk_(true) { m_.lock(); }
~mutex_guard{() { if (must_unlock_) m_.unlock(); }
Volid reset () { m_.unlock(); must_Unlock_ = false; }
Private:

Std: :mutex& 四

[94]
